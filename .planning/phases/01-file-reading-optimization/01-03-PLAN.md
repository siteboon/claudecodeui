---
phase: 01-file-reading-optimization
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - server/projects.js
autonomous: true

must_haves:
  truths:
    - "Session timestamps come from file mtime, not parsed content"
    - "getSessions() uses fs.stat() for timestamps instead of parsing JSONL"
    - "Session sorting by lastActivity still works correctly"
    - "API response includes lastActivity field (backward compatible)"
  artifacts:
    - path: "server/projects.js"
      provides: "Updated getSessions with mtime-based timestamps"
      exports: ["getSessions", "parseJsonlSessions"]
  key_links:
    - from: "getSessions"
      to: "fs.stat"
      via: "file stats for mtime"
      pattern: "stat\\(filePath\\)"
    - from: "getSessions"
      to: "parseJsonlSessions"
      via: "session parsing (still needed for summaries)"
      pattern: "parseJsonlSessions\\("
---

<objective>
Update session timestamp extraction to use file modification time (mtime) instead of parsing timestamps from JSONL content, reducing the amount of content that needs to be parsed.

Purpose: File mtime is reliable for determining when a session was last active (Claude Code updates the file on each interaction). Using mtime avoids parsing large amounts of JSONL content just to find timestamps.

Output: Updated getSessions() and parseJsonlSessions() that use mtime for timestamps.
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-file-reading-optimization/01-RESEARCH.md
@server/projects.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update getSessions to use mtime for initial sorting</name>
  <files>server/projects.js</files>
  <action>
Modify getSessions() (around line 813) to use file mtime as the primary timestamp source:

1. The existing code already gets file stats for sorting (lines 833-840):
```javascript
const filesWithStats = await Promise.all(
  jsonlFiles.map(async (file) => {
    const filePath = path.join(projectDir, file);
    const stats = await fs.stat(filePath);
    return { file, mtime: stats.mtime };
  })
);
filesWithStats.sort((a, b) => b.mtime - a.mtime);
```
This is already correct. Keep this.

2. Pass mtime to parseJsonlSessions as the default timestamp:
```javascript
const result = await parseJsonlSessions(jsonlFile, MAX_ENTRIES_PER_FILE, stats.mtime);
```
Add mtime as third parameter to parseJsonlSessions.

3. In the session objects, ensure lastActivity uses the file mtime:
- Currently sessions track lastActivity from parsed entry.timestamp
- Change to prefer mtime, fall back to parsed timestamp only if mtime unavailable
  </action>
  <verify>
```bash
cd /workspace/projects/claudecodeui
# Check that file stats are being used
grep -n "fs.stat\|mtime" server/projects.js | head -20
```
  </verify>
  <done>
- getSessions() passes mtime to parseJsonlSessions
- File mtime used as primary timestamp source
- Files still sorted by mtime (newest first)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update parseJsonlSessions to use mtime as default timestamp</name>
  <files>server/projects.js</files>
  <action>
Modify parseJsonlSessions() (around line 953) to accept and use mtime:

1. Update function signature:
```javascript
async function parseJsonlSessions(filePath, maxEntries = null, fileMtime = null)
```

2. Use mtime as the session's lastActivity when creating new sessions:
```javascript
if (!sessions.has(entry.sessionId)) {
  sessions.set(entry.sessionId, {
    id: entry.sessionId,
    summary: 'New Session',
    messageCount: 0,
    lastActivity: fileMtime || new Date(),  // Use mtime instead of new Date()
    cwd: entry.cwd || '',
    lastUserMessage: null,
    lastAssistantMessage: null,
    timestampSource: 'mtime'  // Track source for debugging
  });
}
```

3. Remove or simplify the timestamp tracking from parsed content:
- The current code updates session.lastActivity from entry.timestamp on every message
- Change to: only update if entry.timestamp is MORE RECENT than fileMtime (edge case handling)
- This reduces dependency on parsing timestamps from content

4. Add timestampSource field to session object:
- 'mtime' when timestamp came from file stats
- 'parsed' when timestamp came from content (only for edge cases)
- This is optional/internal - can be omitted from API response
  </action>
  <verify>
```bash
cd /workspace/projects/claudecodeui && npm run dev &
sleep 3
# Check sessions have lastActivity
curl -s http://localhost:5001/api/projects | python3 -c "
import sys, json
data = json.load(sys.stdin)
if data:
    for p in data[:2]:
        print(f'Project: {p[\"name\"]}')
        for s in p.get('sessions', [])[:2]:
            print(f'  Session: {s.get(\"id\", \"?\")} lastActivity: {s.get(\"lastActivity\", \"MISSING\")}')
"
pkill -f "node.*server"
```
  </verify>
  <done>
- parseJsonlSessions accepts fileMtime parameter
- New sessions use mtime as initial lastActivity
- timestampSource field tracks where timestamp came from
- Sessions still have valid lastActivity (backward compatible)
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify session sorting still works correctly</name>
  <files>server/projects.js</files>
  <action>
Verify that session sorting works correctly with mtime-based timestamps:

1. Check the sorting in getSessions() (around line 934):
```javascript
const visibleSessions = [...latestFromGroups, ...standaloneSessionsArray]
  .filter(session => !session.summary.startsWith('{ "'))
  .sort((a, b) => new Date(b.lastActivity) - new Date(a.lastActivity));
```
This should still work because lastActivity is still a Date or ISO string.

2. Verify the file-level sorting (lines 833-840) is preserved:
- Files sorted by mtime (newest first)
- This determines which files are processed first

3. Test edge case: What if file mtime is in the future?
- This can happen with clock skew or manually modified files
- The sort should handle this gracefully (future dates just sort to top)

4. Test that Cursor and Codex sessions are not affected:
- getCursorSessions() uses its own timestamp logic (from SQLite db mtime) - verify unchanged
- getCodexSessions() parses timestamps from content - verify unchanged

No changes needed if everything works. Document any issues found.
  </action>
  <verify>
```bash
cd /workspace/projects/claudecodeui && npm run dev &
sleep 3
# Verify sessions are sorted (most recent first)
curl -s http://localhost:5001/api/projects | python3 -c "
import sys, json
from datetime import datetime
data = json.load(sys.stdin)
if data:
    for p in data[:1]:
        sessions = p.get('sessions', [])
        if len(sessions) >= 2:
            dates = [s.get('lastActivity') for s in sessions]
            print(f'Session dates (should be descending): {dates[:3]}')
            # Check descending order
            if all(dates):
                sorted_check = all(dates[i] >= dates[i+1] for i in range(len(dates)-1))
                print(f'Correctly sorted (newest first): {sorted_check}')
"
pkill -f "node.*server"
```
  </verify>
  <done>
- Sessions sorted by lastActivity (newest first)
- File-level sorting by mtime preserved
- Cursor/Codex session timestamps unchanged
- Edge cases handled gracefully
  </done>
</task>

</tasks>

<verification>
Full verification:
```bash
cd /workspace/projects/claudecodeui

# 1. Run existing tests
npm test

# 2. Check mtime usage in code
grep -n "mtime\|timestampSource" server/projects.js

# 3. Start server and verify timestamps
npm run dev &
sleep 3
curl -s http://localhost:5001/api/projects | python3 -c "
import sys, json
data = json.load(sys.stdin)
print(f'Projects loaded: {len(data)}')
for p in data[:2]:
    print(f'  {p[\"name\"]}: {len(p.get(\"sessions\", []))} sessions')
    for s in p.get('sessions', [])[:1]:
        print(f'    lastActivity: {s.get(\"lastActivity\")}')
"
pkill -f "node.*server"
```
</verification>

<success_criteria>
- parseJsonlSessions accepts fileMtime parameter
- Sessions use file mtime as primary timestamp source
- Sessions sorted correctly (newest first)
- lastActivity field present in API response (backward compatible)
- Cursor and Codex sessions unaffected
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-file-reading-optimization/01-03-SUMMARY.md`
</output>
