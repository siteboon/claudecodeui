---
phase: 01-file-reading-optimization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - server/projects.js
  - server/__tests__/projects.test.js
autonomous: true

must_haves:
  truths:
    - "extractCwdFromFirstBytes() reads maximum 100KB from file"
    - "extractCwdFromFirstBytes() stops reading immediately when cwd found"
    - "extractCwdFromFirstBytes() returns null when cwd not in first 100KB"
    - "extractCwdFromFirstBytes() handles malformed JSON gracefully"
  artifacts:
    - path: "server/projects.js"
      provides: "Byte-limited cwd extraction function"
      exports: ["extractCwdFromFirstBytes"]
    - path: "server/__tests__/projects.test.js"
      provides: "Unit tests for byte-limited extraction"
      contains: "extractCwdFromFirstBytes"
  key_links:
    - from: "server/projects.js"
      to: "node:fs"
      via: "createReadStream with end option"
      pattern: "createReadStream.*end:"
---

<objective>
Create a byte-limited JSONL reader that extracts `cwd` from the first 100KB of a file, using TDD to ensure correct behavior at byte boundaries.

Purpose: This is the core memory optimization - reading only 100KB instead of potentially 600MB per file prevents OOM crashes while still finding metadata that appears early in JSONL files.

Output: Tested `extractCwdFromFirstBytes()` function that reads at most 100KB and stops immediately when cwd is found.
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-file-reading-optimization/01-RESEARCH.md
@server/projects.js
</context>

<feature>
  <name>Byte-limited cwd extraction</name>
  <files>server/projects.js, server/__tests__/projects.test.js</files>
  <behavior>
    extractCwdFromFirstBytes(filePath, maxBytes = 100 * 1024) -> string | null

    Cases:
    - File with cwd in line 3 (within 100KB) -> returns cwd value
    - File with cwd after 100KB -> returns null
    - File with no cwd field at all -> returns null
    - File with malformed JSON line at byte boundary -> ignores that line, returns null or cwd from earlier line
    - File smaller than 100KB with cwd -> returns cwd value
    - Empty file -> returns null

    Key implementation details from research:
    - Use createReadStream with { end: maxBytes - 1 } (end is INCLUSIVE)
    - Use readline with crlfDelay: Infinity
    - Call rl.close() then break when cwd found (events can fire after close)
    - Wrap JSON.parse in try/catch for each line (last line may be truncated)
    - Use try/finally to ensure rl.close() cleanup
  </behavior>
  <implementation>
    1. Create async function extractCwdFromFirstBytes(filePath, maxBytes = 100 * 1024)
    2. Create file stream with createReadStream(filePath, { encoding: 'utf8', start: 0, end: maxBytes - 1 })
    3. Create readline interface on that stream
    4. Loop through lines with for await (const line of rl)
    5. For each non-empty line, try JSON.parse
    6. If entry.cwd exists, set foundCwd, call rl.close(), break
    7. In finally block, ensure rl.close() is called
    8. Return foundCwd (null if not found)
    9. Export the function
  </implementation>
</feature>

<verification>
Run tests:
```bash
cd /workspace/projects/claudecodeui && npm test -- --testPathPattern=projects
```

All tests pass including:
- extractCwdFromFirstBytes returns cwd from first 100KB
- extractCwdFromFirstBytes stops at byte limit
- extractCwdFromFirstBytes handles malformed JSON
</verification>

<success_criteria>
- extractCwdFromFirstBytes() function exists and is exported
- Function uses createReadStream with end option (not reading full file)
- Function returns cwd when found in first 100KB
- Function returns null when cwd not in first 100KB
- All unit tests pass
- No memory issues when function is called on large test files
</success_criteria>

<output>
After completion, create `.planning/phases/01-file-reading-optimization/01-01-SUMMARY.md`
</output>
